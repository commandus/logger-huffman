#include <sstream>

#include "logger-sql-clause.h"

/**
 * Initialize logger password directory
 * @param passwords_path path to the catalog with password files
 * @param verbosity if 1, 2 or 3 print out to the stderr errors parsing declarations
 * @return descriptor of the passwords to be passed to the parsePacket()
 */
void* initLoggerPasswords(
	const std::string &passwords_path,
	const int verbosity // default 0
)
{
    return NULL;
}

/**
 * Destroy and free logger properties
 * @param env descriptor
 */
void doneLoggerPasswords(void *env)
{
}

/**
 * Parse packet by declaration
 * @param env packet declaratuions
 * @param outputFormat 0- json(default), 1- csv, 2- tab, 3- sql, 4- Sql, 5- pbtext, 6- dbg, 7- hex, 8- bin
 * @param sqlDialect 0- PostgeSQL, 1- MySQL, 1- Firebird
 * @param packets data
 * @param tableAliases <table alias>=<SQL table name>
 * @param fieldAliases <field name>=<SQL column name>
 * @param properties  <optional field name>=<SQL type name>
 * @return empty string if fails
 */
std::string parsePacket(
	void *env, 
	int outputFormat,
	int sqlDialect,
	const LoggerKosaPackets &packets,
	const std::map<std::string, std::string> *tableAliases,
	const std::map<std::string, std::string> *fieldAliases,
	const std::map<std::string, std::string> *properties
)
{
    return "";
}

// replace string
static std::string replaceString(const std::string &str, const std::string &from, const std::string &to)
{
    size_t start_pos = str.find(from);
    if (start_pos == std::string::npos)
        return str;
    std::string ret(str);
    ret.replace(start_pos, from.length(), to);
    return ret;
}

static std::string getSqlDialectTypeName(
        const std::string &typeName,
        int sqlDialect
)
{
    return "INTEGER";
}

/**
 *  POSTGRESQL 10.x, MYSQL, FIREBIRD 3,x), SQLITE
 */
const std::vector <std::vector <std::pair<std::string, std::string> >> fldNTypes =
        {
                {   // Postgres
                        {"id", "bigint generated always as identity"},
                        {"kosa", "smallint"},
                        {"year", "smallint"},
                        {"no", "smallint"},
                        {"measured", "integer"},
                        {"received", "integer"},
                        {"vcc", "real"},
                        {"vbat", "real"},
                        {"t", "text"},
                        {"raw", "text"}
                },
                {   // Firebird
                        {"id", "bigint generated by default as identity primary key"},
                        {"kosa", "integer"},
                        {"year", "integer"},
                        {"no", "integer"},
                        {"measured", "integer"},
                        {"received", "integer"},
                        {"vcc", "float"},
                        {"vbat", "float"},
                        {"t", "text"},
                        {"raw", "text"}
                },
                {   // MySQL
                        {"id", "bigint NOT NULL AUTO_INCREMENT"},
                        {"kosa", "integer"},
                        {"year", "integer"},
                        {"no", "integer"},
                        {"measured", "integer"},
                        {"received", "integer"},
                        {"vcc", "float"},
                        {"vbat", "float"},
                        {"t", "text"},
                        {"raw", "text"}
                },
                {   // SQLite
                        {"id", "integer PRIMARY KEY AUTOINCREMENT"},
                        {"kosa", "integer"},
                        {"year", "integer"},
                        {"no", "integer"},
                        {"measured", "integer"},
                        {"received", "integer"},
                        {"vcc", "real"},
                        {"vbat", "real"},
                        {"t", "text"},
                        {"raw", "text"}
                }
        };

static void createTableSQLClause1(
        std::ostream *output,
        void *env,
        const std::string &tableName,
        int sqlDialect,
        const std::map<std::string, std::string> *extraFields
)
{
    std::string quote;
    if (sqlDialect == SQL_MYSQL)
        quote = "`";	// MySQL exceptions for spaces and reserved words
    else
        quote = "\"";

    *output << "CREATE TABLE " << quote << replaceString(tableName, ".", "_") << quote << "(";

    bool isFirst = true;
    if (sqlDialect < fldNTypes.size()) {
        for (std::vector<std::pair<std::string, std::string> >::const_iterator it(fldNTypes[sqlDialect].begin());
             it != fldNTypes[sqlDialect].end(); it++) {
            if (isFirst)
                isFirst = false;
            else
                *output << ", ";
            *output << quote << it->first << quote << " " << it->second;
        }
    }
    if (extraFields) {
        for (std::map<std::string, std::string>::const_iterator it(extraFields->begin()); it != extraFields->end(); it++)
        {
            if (isFirst)
                isFirst = false;
            else
                *output << ", ";
            *output << quote << it->first << quote << " " << it->second;            // force string type
        }
    }

    *output << ");";
}

/**
 * Return CREATE table SQL clause
 * @param env packet declaratuions
 * @param outputFormat 3- sql, 4- Sql
 * @param sqlDialect 0- PostgeSQL, 1- MySQL, 1- Firebird
 * @param extraValues  <optional field name>=<SQL type name>
 * @return empty string if fails
 */
std::string createTableSQLClause(
	void *env, 
	int outputFormat,
	int sqlDialect,
	const std::map<std::string, std::string> *extraValues
)
{
    std::stringstream ss;
    std::string tableName = "table";

    switch (outputFormat) {
        case OUTPUT_FORMAT_SQL2:
            createTableSQLClause1(&ss, env, tableName, sqlDialect, extraValues);
        default:
            createTableSQLClause1(&ss, env, tableName, sqlDialect, extraValues);
    }
    return ss.str();
}
